#!/usr/bin/env python3
import collections
import os
import time
import io
import urllib.request
import sys
import codecs # Used for handling utf16 le BOM

import yaml
import boto3 # AWS SDK
# if this is running in the pytest suite, symlink destination names have been adjusted to make importing easier
if 'pytest' in sys.modules:
    from base_adjust import Adjust  # adjust.py renamed to base adjust to allow this file to be imported normally for testing
else:
    from adjust import Adjust

DESC = "EC2 Windows Server adjust driver for Opsani Optune"
VERSION = "0.0.3"
HAS_CANCEL = False

INST_TYPES=('t2.nano','t2.micro','t2.small','t2.medium','t2.large','t2.xlarge','t2.2xlarge','m4.large','m4.xlarge','m4.2xlarge','m4.4xlarge','m4.10xlarge','m4.16xlarge','r4.large','r4.xlarge','r4.2xlarge','r4.4xlarge','r4.8xlarge','r4.16xlarge','x1.16xlarge','x1.32xlarge','x1e.xlarge','x1e.2xlarge','x1e.4xlarge','x1e.8xlarge','x1e.16xlarge','x1e.32xlarge','i2.xlarge','i2.2xlarge','i2.4xlarge','i2.8xlarge','i3.large','i3.xlarge','i3.2xlarge','i3.4xlarge','i3.8xlarge','i3.16xlarge','i3.metal','c4.large','c4.xlarge','c4.2xlarge','c4.4xlarge','c4.8xlarge','c5.large','c5.xlarge','c5.2xlarge','c5.4xlarge','c5.9xlarge','c5.18xlarge','c5d.large','c5d.xlarge','c5d.2xlarge','c5d.4xlarge','c5d.9xlarge','c5d.18xlarge','g3.4xlarge','g3.8xlarge','g3.16xlarge','p2.xlarge','p2.8xlarge','p2.16xlarge','p3.2xlarge','p3.8xlarge','p3.16xlarge','d2.xlarge','d2.2xlarge','d2.4xlarge','d2.8xlarge','m5.large','m5.xlarge','m5.2xlarge','m5.4xlarge','m5.12xlarge','m5.24xlarge','m5d.large','m5d.xlarge','m5d.2xlarge','m5d.4xlarge','m5d.12xlarge','m5d.24xlarge','h1.2xlarge','h1.4xlarge','h1.8xlarge','h1.16xlarge',)

config_path = os.environ.get('OPTUNE_CONFIG', './config.yaml')

def dict_merge(d, m):
    for k, v in m.items():
        if k in d and isinstance(d[k], dict) and isinstance(m[k], collections.Mapping):
            dict_merge(d[k], m[k])
        else:
            d[k] = m[k]


class Ec2WinDriver(Adjust):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if not (self.args.info or self.args.version):
            self.config = self.load_config()
            self.check_config(self.config)
            self.s3 = boto3.client('s3') # credentials are retreieved from env vars or /root/.aws
            self.ec2 = boto3.client('ec2')
            self.asg = boto3.client('autoscaling')

    @staticmethod
    def load_config():
        try:
            config = yaml.safe_load(open(config_path))
        except yaml.YAMLError as e:
            raise Exception('Could not parse config file located at "{}". '
                            'Please check its contents. Error: {}'.format(config_path, str(e)))
        return config

    @staticmethod
    def check_config(config):
        if not os.path.isdir('/root/.aws') and not os.path.isdir('{}/.aws'.format(os.path.expanduser('~'))):
            assert os.environ.get('AWS_ACCESS_KEY_ID', '') != '' and os.environ.get('AWS_SECRET_ACCESS_KEY', '') != '', 'No Amazon S3 access key was provided. ' \
                                            'Please refer to README.md.'
            assert os.environ.get('AWS_DEFAULT_REGION', '') != '', 'No Amazon S3 default region was provided. ' \
                                            'Please refer to README.md.'

        c = config
        assert c and c.get('ec2win', None), 'EC2 Windows Server Configuration was not provided in "{}". ' \
                                        'Please refer to README.md'.format(config_path)

        top_level = c.get('ec2win')
        assert len(top_level) > 0, 'Component Configuration was not provided in "{}". ' \
                                        'Please refer to README.md'.format(config_path)
        assert isinstance(top_level, dict), 'Component Configuration was malformed in "{}". ' \
            'Expected dict, found {}'.format(config_path, top_level.__class__.__name__)

        config_asgs = set()
        ref_component = '' # string: if ref_asg defined, this is set to component name
        for component_key in top_level:
            component_val = top_level[component_key]
            assert isinstance(component_val, dict), 'Invalid config section for component {}. Expected dict, found {}'.format(
                component_key, component_val.__class__.__name__
            )

            assert component_val.get('s3_bucket', None), 'Amazon S3 bucket name was not provided in "{}". ' \
                                            'Please refer to README.md.'.format(config_path)
            assert isinstance(component_val['s3_bucket'], str), 'Amazon S3 bucket name must be a string'
            assert component_val.get('s3_path', None), 'Amazon S3 path was not provided in "{}". ' \
                                            'Please refer to README.md.'.format(config_path)
            assert isinstance(component_val['s3_path'], str), 'Amazon S3 path must be a string'

            dprt = component_val.get('describe_port', None)
            if dprt:
                assert (isinstance(dprt, str) and (0 < int(dprt) <= 65535)) or (isinstance(dprt, int) and (0 < dprt <= 65535)), \
                'Describe port must be a valid port number when provided'

            de = component_val.get('describe_endpoint', None)
            if de:
                assert isinstance(de, str), 'Describe endpoint must be a string containing path to describe when provided'
            

            ei = component_val.get('ec2_ip', None)
            if ei: # Minimal validation since this is mostly for debug using a single instance, should warn in production if still part of codebase
                assert isinstance(ei, str), 'EC2 Ip must be a string containing IP address when provided'

            a = component_val.get('asg', None)
            assert a, 'One or more Auto Scaling Group names must be provided to facilitate updating of launch config'
            assert isinstance(a, str), 'Target ASGs must be a string value (comma sperated for multiple values)'

            comp_asgs = set()
            for asg in a.split(','):
                assert asg not in config_asgs, 'Target ASG {} was found under multiple roles/components which may produce undesired behaviour'.format(asg)
                assert asg not in comp_asgs, 'Target ASG {} was defined twice in a single role/component which may produce undesired behaviour'.format(asg)
                comp_asgs.add(asg)

            config_asgs.update(comp_asgs)

            ra = component_val.get('ref_asg', None)
            if ra:
                assert ref_component == '', 'Reference ASG already defined in component {} cannot be redefined in component {}'.format(ref_component, component_key)
                assert isinstance(ra, str), 'Reference ASGs must be a string value (comma sperated for multiple values)'
                ref_component = component_key
            
            bs = component_val.get('batch_size', None)
            if bs:
                assert isinstance(bs, int) and bs > 0, 'Batch size must be a (>0) integer when provided'

            tapb = component_val.get('timeout_adjust_per_batch', None)
            if tapb:
                assert isinstance(tapb, int) and bs > 0, 'Time out per batch must be a (>0) integer when provided'

            tic = component_val.get('timeout_inst_create', None)
            if tic:
                assert isinstance(tic, int) and bs > 0, 'Time out for instance creation must be a (>0) integer when provided'

            tisc = component_val.get('timeout_inst_status_check', None)
            if tisc:
                assert isinstance(tisc, int) and bs > 0, 'Time out for instance status checks must be a (>0) integer when provided'
            
            bc = component_val.get('batch_cooldown', None)
            if bc:
                assert isinstance(bc, int) and bc > 0, 'Batch cooldown time must be a (>0) integer when provided'

            it = component_val.get('inst_types', None)
            if it:
                assert isinstance(it, list) and len(it) > 0, 'Instance types must be a (>0 length) list when provided'
                assert all(isinstance(t, str) for t in it), 'All instance types must be string values when provided'

            assert component_val.get('encoder', None), 'Section "encoder" was not provided in "{}". ' \
                                            'Please refer to README.md.'.format(config_path)

    def adjust(self, data=None):
        assert data, 'Received no settings to adjust.'
        # TODO: fix progress percentages
        # num_components = len(self.config['ec2win'])
        self.progress = 0
        for component_key in self.config['ec2win']:
            settings = data['application']['components'].pop(component_key, {}).get('settings')
            if not settings:
                continue # no settings for this component
            self.progress_message = "adjusting {} component. Encoding windows settings".format(component_key)
            self.print_progress()

            import encoders.base as enc
            script = enc.encode(self.config['ec2win'][component_key]['encoder'], settings)[0]
            
            # NOTE: counting of windows settings is based on all settings starting with "Set-", may need to add new encoder func if this changes
            size = len(script.split('Set-')) - 1
            # Adjust windows settings
            if size > 0:
                # self.progress = 25
                self.progress_message = "encoded {} windows settings, uploading powershell script to bucket".format(size)
                self.print_progress()

                script_bytes = script.encode()
                self.s3.put_object(Body=script_bytes, Bucket=self.config['ec2win'][component_key]['s3_bucket'], Key=self.config['ec2win'][component_key]['s3_path'])

            # self.progress = 50
            self.progress_message = "adjusted {} windows settings".format(size)
            self.print_progress()
        
            # Adjust ASG launch template if needed
            groups = self.config["ec2win"][component_key]["asg"].split(",")

            changed_lst = []
            new_inst_type = settings.get('inst_type')
            if new_inst_type:
                new_inst_type_val = new_inst_type.get("value")
                if not new_inst_type_val:
                    raise Exception("No 'value' key provided inst_type dict")

                for g in groups:
                    asg_lt_info = self.query_asg_launch_template(g) # tuple [3]

                    if new_inst_type_val == asg_lt_info[0]:
                        continue # current template version has same instance type

                    new_lt_data = { "InstanceType": new_inst_type_val }
                    self.ec2.create_launch_template_version(LaunchTemplateName=asg_lt_info[1],SourceVersion=str(asg_lt_info[2]), LaunchTemplateData=new_lt_data)
                    # Done here. NOTE: assumes ASG is configured to reference latest launch template
                    changed_lst.append(g)

            size = len(changed_lst)
            # self.progress = 60
            self.progress_message = "adjusted {} asg launch templates".format(size)
            self.print_progress()

            # Terminate batch_size instances in each group belonging to the component, wait for ready before terminating next batch
            bs = self.config['ec2win'][component_key].get('batch_size', 1)

            grp_insts = {}
            validated_insts = {} # keep track of validated instance IDs to exclude from describe endpoint validation
            wait_counts = {} # count of total number of instances per group, used to track re-instancing process
            num_batches = 1
            num_instances = 0
            for g in groups:
                grp_insts[g] = [ i["InstanceId"] for i in self.get_asg_instances(g) if i["LifecycleState"] == "InService" ] 
                if len(grp_insts[g]) < 1:
                    grp_insts.pop(g)
                else:
                    wait_counts[g] = len(grp_insts[g])
                    validated_insts[g] = []
                    num_instances += wait_counts[g]
                    num_batches = max(num_batches, (wait_counts[g]//bs + 1 if wait_counts[g]%bs > 0 else 0 ))
            cur_batch_num = 0

            # Empty dict == false
            if not grp_insts:
                raise Exception('Component {}: no group instances to adjust in ASG(s) {}'.format(component_key, ', '.join(groups)))
            num_asgs = len(grp_insts)
            # self.progress = 65
            self.progress_message = "Terminating {} ASGs totalling {} instances in {} batches of {}".format(num_asgs, num_instances, num_batches, bs)
            self.print_progress()

            outer_start_time = time.time()
            adjust_timeout = self.config['ec2win'][component_key].get('timeout_adjust_per_batch', 720) * num_batches

            if self.config['ec2win'][component_key].get('describe_endpoint'): # format validation endpoint when provided
                desc_endpoint_frmtstr = 'http://{{}}:{}/{}'.format(self.config['ec2win'][component_key].get('describe_port', 8080), self.config['ec2win'][component_key]['describe_endpoint'])
            while len(grp_insts) > 0:
                cur_batch_num += 1
                self.progress_message = "Terminating {} ASGs totalling {} instances in batches of {}: batch {} of {}".format(num_asgs, num_instances, bs, cur_batch_num, num_batches)
                self.print_progress()

                if time.time() - outer_start_time > adjust_timeout:
                    raise Exception("Timed out waiting for all batches to complete adjustment")
                term_batch = []

                # Store current keys as they may be removed by the time we wait
                wait_list = list(grp_insts.keys())
                
                copy_grp_insts = dict(grp_insts)
                for g in copy_grp_insts:
                    rmng_insts = grp_insts.pop(g, None)

                    if rmng_insts is None:
                        continue
                    
                    term_batch.extend(rmng_insts[:bs])
                    rmng_insts = rmng_insts[bs:]
                    if len(rmng_insts) > 0: # If no more to terminate, remove key from grp_insts
                        grp_insts[g] = rmng_insts
                
                # Terminate instances
                if len(term_batch) < 1:
                    raise Exception("Failed to get inservice instances to terminate for component {}".format(component_key))
                resp = self.ec2.terminate_instances(InstanceIds = term_batch)
                if not resp.get('TerminatingInstances'):
                    raise Exception("Failed to terminate instances for component {}. Response: {}", component_key, resp)

                termed_ids = [i['InstanceId'] for i in resp['TerminatingInstances']]
                if len(term_batch) != len(termed_ids):
                    raise Exception("Failed to terminate instances for component {}. Batch Ids: {}. Terminated Ids: {}", component_key, ', '.join(term_batch), ', '.join(termed_ids))

                # Wait for ASGs to reach pre-termination quantity of instances
                instances_reinstantiated = False
                start_time = time.time()
                heartbeat_counter = 0
                while not instances_reinstantiated:
                    time.sleep(15)
                    instances_reinstantiated = True
                    for g in wait_list:
                        non_term_insts = [ 
                            i["InstanceId"] for i in self.get_asg_instances(g) 
                            if i["InstanceId"] not in term_batch
                            and i["LifecycleState"] == "InService" ]
                        if len(non_term_insts) != wait_counts[g]:
                            instances_reinstantiated = False
                            break
                    
                    heartbeat_counter = (heartbeat_counter + 1) % 2
                    if heartbeat_counter == 0:
                        self.print_progress()

                    if time.time() - start_time > self.config['ec2win'][component_key].get('timeout_inst_create', 300):
                        raise Exception("Timed out waiting for ASG to make new instances")
                
                if heartbeat_counter == 1:
                    self.print_progress()

                # Wait for all instances in each wait group to pass status checks
                instances_ready = False
                start_time = time.time()
                heartbeat_counter = 0
                while not instances_ready:
                    instances_ready = True
                    for g in wait_list:
                        cur_insts = [ 
                            i["InstanceId"] for i in self.get_asg_instances(g) 
                            if i["InstanceId"] not in term_batch 
                            and i["LifecycleState"] == "InService" ]
                        inst_stats = self.ec2.describe_instance_status(InstanceIds=cur_insts)
                        if not len(inst_stats["InstanceStatuses"]):
                            instances_ready = False
                            break
                        for stat in inst_stats["InstanceStatuses"]:
                            if stat["InstanceStatus"].get("Status") != "ok" or stat["SystemStatus"].get("Status") != "ok":
                                instances_ready = False
                                break
                        if not instances_ready:
                            break
                    time.sleep(15)

                    heartbeat_counter = (heartbeat_counter + 1) % 2
                    if heartbeat_counter == 0:
                        self.print_progress()

                    if time.time() - start_time > self.config['ec2win'][component_key].get('timeout_inst_status_check', 300):
                        raise Exception("Timed out waiting for new instances to pass status check")
                
                if heartbeat_counter == 1:
                    self.print_progress()

                if not self.config['ec2win'][component_key].get('describe_endpoint'):
                    # wait an amount of time to allow windows init to finish, split in 30s intervals for heartbeat
                    batch_cooldown = self.config['ec2win'][component_key].get('batch_cooldown', 120)
                    for _ in range(batch_cooldown // 30):
                        time.sleep(30)
                        self.print_progress()
                    
                    if batch_cooldown % 30 > 0:
                        time.sleep(batch_cooldown % 30)
                        self.print_progress()
                else:
                    new_insts = {}
                    for g in wait_list:
                        new_insts[g] = [ i["InstanceId"] for i in self.get_asg_instances(g)
                            # terminated instances continue to show up for a while after termination
                            if i["LifecycleState"] == "InService"
                            and i["InstanceId"] not in term_batch
                            # and not in instances yet to be terminated
                            and i["InstanceId"] not in grp_insts.get(g, [])
                            # and not in instances we've already validated
                            and i["InstanceId"] not in validated_insts[g] ]
                        
                        if len(new_insts[g]) < 1:
                            new_insts.pop(g)

                    list_new_inst_ids = []
                    for g in new_insts:
                        list_new_inst_ids.extend(new_insts[g])

                    if len(list_new_inst_ids) != len(term_batch):
                        raise Exception("Unable to retrieve new EC2 instances for groups {}. Count found: {}, count expected: {}".format(', '.join(wait_list) , len(list_new_inst_ids), len(term_batch)))

                    inst_stat_resp = self.ec2.describe_instances(InstanceIds=list_new_inst_ids)
                    if not inst_stat_resp or not inst_stat_resp.get('Reservations'):
                        raise Exception("Unable to describe new EC2 instances via boto3 client. Response: {}".format(inst_stat_resp))

                    new_inst_ips = []
                    for r in inst_stat_resp['Reservations']:
                        new_inst_ips.extend([i['PublicIpAddress'] for i in r['Instances'] ])

                    if len(new_inst_ips) != len(term_batch):
                        raise Exception("Unable to retrieve IP addresses for new EC2 instances. Count found: {}, count expected: {}".format(len(new_inst_ips), len(term_batch)))

                    adjust_validated = False
                    start_time = time.time()
                    heartbeat_counter = 0
                    while not adjust_validated:
                        adjust_validated = True
                        for i in new_inst_ips:
                            desc_endpoint = desc_endpoint_frmtstr.format(i)
                            try:
                                describe_resp = urllib.request.urlopen(url=desc_endpoint, timeout=10)
                            except urllib.error.URLError: # 10s timeout will trigger URLError but that is expected on fresh instances
                                adjust_validated = False
                                break # Not ready yet
                            if describe_resp.status != 200:
                                adjust_validated = False
                                break # Not ready yet
                
                            raw_data = describe_resp.read()
                            if raw_data.startswith(codecs.BOM_UTF16_LE):
                                raw_data = raw_data[len(codecs.BOM_UTF16_LE):] # remove BOM
                                describe_data = raw_data.decode('utf_16_le')
                            else:
                                raise Exception ("Servo describe data returned with unexpected encoding. Only utf_16_le is supported currently")
                
                            desc_settings = self.encode_describe_if_needed(None, self.config['ec2win'][component_key], describe_data)
                            for key in desc_settings:
                                if settings.get(key) and desc_settings[key]['value'] != settings[key]['value']:
                                    raise Exception('Validation failed for setting {}: describe endpoint value {} did not match input value {}'.format(
                                            key,
                                            desc_settings[key]['value'],
                                            settings[key]['value']
                                        ))
                            
                        time.sleep(5)
                        heartbeat_counter = (heartbeat_counter + 1) % 2
                        if heartbeat_counter == 0:
                            self.print_progress()

                        if time.time() - start_time > self.config['ec2win'][component_key].get('timeout_inst_adjust_validated', 300):
                            raise Exception("Timed out waiting for validation of new instances' adjustments")
                    
                    # Validation complete, add current iteration to validated list
                    for g in new_insts:
                        validated_insts[g].extend(new_insts[g])


        # check for components not in config
        if data['application']['components']:
            self.print_json_error(
                "none",
                "warning",
                "input data contains unknown components: "+ repr(list(data['application']['components'].keys()))
            )
        
        self.progress = 100
        self.progress_message = "adjust complete"
        self.print_progress()
            
        

    def get_asg_instances(self, gname):
        a = self.asg.describe_auto_scaling_groups(AutoScalingGroupNames=[gname])
        # describe_auto_.. doesn't fail if asg not found, check for it:
        if not a.get("AutoScalingGroups"):
            raise Exception("Auto-scaling Group {} does not exist".format(gname))
        g = a["AutoScalingGroups"][0]

        return g.get("Instances", [])


    def query(self):
        retVal = {'application':{'components': {}}}

        for component_key in self.config['ec2win']:
            # Query Windows settings
            ec2_ip = self.config['ec2win'][component_key].get('ec2_ip')
            retVal['application']['components'][component_key] = { 'settings': {} }
            if ec2_ip is None:
                try:
                    response = self.s3.get_object(Bucket=self.config['ec2win'][component_key]['s3_bucket'], Key=self.config['ec2win'][component_key]['s3_path'])
                    describe_string = response['Body'].read().decode('utf-8')
                except Exception as e:
                    self.print_json_error(
                        e.__class__.__name__,
                        "failure",
                        str(e)
                    )
                    describe_string = ''
                retVal['application']['components'][component_key]['settings'] = self.encode_describe_if_needed(None, self.config['ec2win'][component_key], describe_string)

            else:
                describe_port = self.config['ec2win'][component_key].get('describe_port', '8080')
                desc_path = self.config['ec2win'][component_key].get('describe_endpoint', 'describe.json')
                desc_endpoint = 'http://{}:{}/{}'.format(ec2_ip, describe_port, desc_path)
                describe_resp = urllib.request.urlopen(desc_endpoint)
                if describe_resp.status == 404:
                    raise Exception ("Servo describe data could not be located at web endpoint '{}'".format(desc_endpoint))

                if describe_resp.status != 200:
                    raise Exception ("Servo describe web endpoint ('{}') returned status '{}'".format(desc_endpoint, describe_resp.status))

                raw_data = describe_resp.read()
                if raw_data.startswith(codecs.BOM_UTF16_LE):
                    raw_data = raw_data[len(codecs.BOM_UTF16_LE):]
                    describe_data = raw_data.decode('utf_16_le')
                else:
                    raise Exception ("Servo describe data returned with unexpected encoding. Only utf_16_le is supported currently")

                retVal['application']['components'][component_key]['settings'] = self.encode_describe_if_needed(None, self.config['ec2win'][component_key], describe_data)

            # Query ASG settings
            groups = self.config['ec2win'][component_key]['asg'].split(",")
            ref_groups = self.config['ec2win'][component_key].get('ref_asg')
            if ref_groups:
                ref_groups = ref_groups.split(",")
            
            tgt_insts = []
            ref_insts = []

            it_settings = self.config['ec2win'][component_key].get('settings', {}).get('inst_type', {})
            inst_vals = it_settings.get('values', list(INST_TYPES))
            it_type = it_settings.get('type', 'enum')
            it_unit = it_settings.get('unit', 'ec2')
            for gname in groups:
                val = self.query_asg_launch_template(gname)[0]
                retVal['application']['components'][component_key]['settings']["inst_type"] = { "value" : val, "type" : it_type, "values" : inst_vals, "unit" : it_unit }
                if(ref_groups):
                    tgt_insts.extend(self.get_asg_instances(gname))
        

            if ref_groups:
                for gname in ref_groups:
                    ref_insts.extend(self.get_asg_instances(gname))
                    
                retVal['monitoring'] = {
                    'instance_ids': [ i["InstanceId"] for i in tgt_insts],
                    'ref_instance_ids': [ i["InstanceId"] for i in ref_insts]
                }
        
        return retVal

    def query_asg_launch_template(self, gname):
        a = self.asg.describe_auto_scaling_groups(AutoScalingGroupNames=[gname])
        if not a.get("AutoScalingGroups"):
            raise Exception("Auto-scaling Group {} does not exist".format(gname))
        g = a["AutoScalingGroups"][0]
        launch_template = g.get("LaunchTemplate")
        if launch_template is None:# must be able to retrieve launch template. Launch configs are not as programatically flexible, thus are not supported (yet)
            raise Exception("Could not retrieve launch template for group {}. This driver does not currently support updating instance types of launch groups".format(gname))
            
        
        args = launch_template.copy()
        if "LaunchTemplateId" in args:
            args.pop("LaunchTemplateName",None) # keep only one of Id or Name in the args
        args["Versions"] =  [args.pop("Version","$Latest")]
        cur_template_ver = self.ec2.describe_launch_template_versions(**args)['LaunchTemplateVersions'][0] # should be only one

        return ( 
            cur_template_ver["LaunchTemplateData"]["InstanceType"],
            launch_template["LaunchTemplateName"],
            cur_template_ver["VersionNumber"]
        )


    def encode_describe_if_needed(self, name, data, value):
        """
        Takes:
            * a setting name
            * setting data (as defined in the config)
            * value (as returned by the underlying infrastructure)

        Returns a dict in the format { <setting_name> : { <setting_data> }},
        suitable for returning as a description. At the very minimun,
        <setting_data> will return the current "value". If the config for that
        setting specifies an encoder to be used, the returned "value" ( in
        <setting_data>) will be decoded by the encoder specified in the config.
        """
        import encoders.base as enc
        return enc.describe(data["encoder"], value)


if __name__ == '__main__':
    driver = Ec2WinDriver(cli_desc=DESC, supports_cancel=HAS_CANCEL, version=VERSION)
    driver.run()
